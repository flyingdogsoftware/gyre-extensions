var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/index.js
__export(exports, {
  binarySearch: () => binarySearch,
  clamp: () => clamp,
  commas: () => commas,
  createSprite: () => createSprite,
  linearScale: () => linear,
  padLeft: () => padLeft,
  pickRandom: () => pickRandom,
  queue: () => queue,
  random: () => random,
  seedRandom: () => seedRandom,
  shuffle: () => shuffle,
  sleep: () => sleep
});

// src/array/binarySearch.js
var default_sort = (item, needle) => item - needle;
function binarySearch(array, search, fn = default_sort) {
  let low = 0;
  let high = array.length - 1;
  const sort = fn.length === 1 ? (item, needle) => fn(item) - search : fn;
  while (low <= high) {
    const i = high + low >> 1;
    const d = sort(array[i], search);
    if (d < 0) {
      low = i + 1;
    } else if (d > 0) {
      high = i - 1;
    } else {
      return i;
    }
  }
  return -low - 1;
}

// src/array/pickRandom.js
function pickRandom(array) {
  const i = ~~(Math.random() * array.length);
  return array[i];
}

// src/array/shuffle.js
function shuffle(array) {
  let m = array.length;
  while (m > 0) {
    const i = Math.floor(Math.random() * m--);
    const t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}

// src/async/queue.js
function queue(max = 4) {
  const items = [];
  let pending = 0;
  let closed = false;
  let fulfil_closed;
  function dequeue() {
    if (pending === 0 && items.length === 0) {
      if (fulfil_closed)
        fulfil_closed();
    }
    if (pending >= max)
      return;
    if (items.length === 0)
      return;
    pending += 1;
    const { fn, fulfil, reject } = items.shift();
    const promise = fn();
    try {
      promise.then(fulfil, reject).then(() => {
        pending -= 1;
        dequeue();
      });
    } catch (err) {
      reject(err);
      pending -= 1;
      dequeue();
    }
    dequeue();
  }
  return {
    add(fn) {
      if (closed) {
        throw new Error(`Cannot add to a closed queue`);
      }
      return new Promise((fulfil, reject) => {
        items.push({ fn, fulfil, reject });
        dequeue();
      });
    },
    close() {
      closed = true;
      return new Promise((fulfil, reject) => {
        if (pending === 0) {
          fulfil();
        } else {
          fulfil_closed = fulfil;
        }
      });
    }
  };
}

// src/async/sleep.js
function sleep(ms) {
  return new Promise((fulfil) => {
    setTimeout(fulfil, ms);
  });
}

// src/canvas/sprite.js
function createSprite(width2, height, fn) {
  const canvas = document.createElement("canvas");
  canvas.width = width2;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  fn(ctx, canvas.width, canvas.height);
  return canvas;
}

// src/number/clamp.js
function clamp(num, min, max) {
  return num < min ? min : num > max ? max : num;
}

// src/number/random.js
function random(a, b) {
  if (b === void 0)
    return Math.random() * a;
  return a + Math.random() * (b - a);
}

// src/number/seedRandom.js
var width = 256;
var chunks = 6;
var digits = 52;
var startdenom = Math.pow(width, chunks);
var significance = Math.pow(2, digits);
var overflow = significance * 2;
var mask = width - 1;
var ARC4 = class {
  constructor(key) {
    this.i = 0;
    this.j = 0;
    this.S = [];
    for (let i = 0; i < width; i += 1) {
      this.S[i] = i;
    }
    const len = key.length;
    let t;
    let j = 0;
    for (let i = 0; i < width; i += 1) {
      this.S[i] = this.S[j = mask & j + key[i % len] + (t = this.S[i])];
      this.S[j] = t;
    }
    this.g(width);
  }
  g(count) {
    const s = this.S;
    let r = 0;
    while (count--) {
      const t = s[this.i = mask & this.i + 1];
      r = r * width + s[mask & (s[this.i] = s[this.j = mask & this.j + t]) + (s[this.j] = t)];
    }
    return r;
  }
};
function seedRandom(seed) {
  if (!seed)
    seed = "\0";
  const key = [];
  let smear;
  for (let i = 0; i < seed.length; i += 1) {
    key[mask & i] = mask & (smear ^= key[mask & i] * 19) + seed.charCodeAt(i);
  }
  const arc4 = new ARC4(key);
  function prng() {
    let n = arc4.g(chunks);
    let d = startdenom;
    let x = 0;
    while (n < significance) {
      n = (n + x) * width;
      d *= width;
      x = arc4.g(1);
    }
    while (n >= overflow) {
      n /= 2;
      d /= 2;
      x >>>= 1;
    }
    return (n + x) / d;
  }
  function random2(a, b) {
    if (b === void 0)
      return prng() * a;
    return a + prng() * (b - a);
  }
  return random2;
}

// src/scale/linear.js
function linear(domain, range) {
  const d0 = domain[0];
  const r0 = range[0];
  const m = (range[1] - r0) / (domain[1] - d0);
  function scale(num) {
    return r0 + (num - d0) * m;
  }
  scale.inverse = () => linear(range, domain);
  return scale;
}

// src/string/commas.js
function commas(num) {
  const parts = String(num).split(".");
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return parts.join(".");
}

// src/string/padLeft.js
function padLeft(input, length = 2, char = "0") {
  let output = String(input);
  while (output.length < length)
    output = char + output;
  return output;
}
